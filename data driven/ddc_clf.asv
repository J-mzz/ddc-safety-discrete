close all;clear;clc
yalmip('clear')

rng(1)

%% system and data generation

% yalmip setup
sdpvar x1 x2 x3 x4
var = [x1;x2];              % x
var_lift = [x3;x4];         % \tilde{x}: x3 = next(x1), x4 = next(x2)
var_aug = [var; var_lift];  % [x; \tilde{x}]

% define DT system: x+ = f(x) + g(x)*u(x) + noise
eg = 1;                     % 1 (linear) or 2 (nonlinear)
[f,g] = getSystem(eg,vars); 

% setup
Cons = setCons(eg);

% noise level (no noise for now)
eps = 0;                    % noise level for robust data driven
epsw = 0;                   % noise level of disturbance

% generate data, with input u \in [-1,1]
X = getDataRND(eg,eps,Cons.T);

% consistency set
[A,B,xi] = getCons(X,Cons);

% check enough data
N = [A B; -A -B];
if rank(N) ~= size(N,2)
    error('Not enough data collected!')
end
e = [eps*ones(Cons.n*Cons.T,1)+xi; eps*ones(Cons.n*Cons.T,1)-xi];

% keep nontrivial constraints
[N_red, e_red] = nontrivial_constraints(N, e);

% update Cons
Cons.N = N_red;
Cons.e = e_red;
Cons.A = A;
Cons.B = B;
Cons.xi = xi;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% try to solve

A   = Cons.A;
B   = Cons.B;
xi  = Cons.xi;
n   = Cons.n;
T   = Cons.T;
df  = Cons.df;
dg  = Cons.dg;
N   = Cons.N;
e   = Cons.e;

%% change the value of FLAG to switch from p(x) and p(x,\tilde{x})

FLAG = 1;   % FLAG = 0 -->  p(x)
            % FLAG = 1 -->  p(x,\tilde{x})

%% SOS set up

dp = 2;     % degree of vecter polynomial p = [p1; p2]
dv = 4;     % degree of lyapunov function v

% multiplier p
if ~FLAG
    % p(x)
    [p1,c1] =   polynomial(var, dp, 0);
    [p2,c2] =   polynomial(var, dp, 0);
    [p2u,c2u] = polynomial(var, dp, 0);     % p2u = p2*u
else
    % p(x, \tilde{x})
    [p1,c1] =   polynomial(var_aug, dp, 0);
    [p2,c2] =   polynomial(var_aug, dp, 0);
    [p2u,c2u] = polynomial(var_aug, dp, 0); % p2u = p2*u
end

% lyapunov function v
[v, cv] =  polynomial(var, dv, 1);          % 1 -> without constant
[vt,cvt] = polynomial(var_lift, dv, 1);

% vp and vf
[~,~,vf] = polynomial(vars,df,1);
[~,~,vg] = polynomial(vars,dg,0);

% auxiliary varible Y
Y = zeros(1, size(N,1), 'like', sdpvar);	% the polynomial matrix Y
for i = 1:size(N,1)
    Y(i) = polynomial(var_aug, dv, 0);
end

% for stable set P2
r = [ - kron(vf',[p1, p2]), - kron(vg', [0, p2u])];


F = [ 
     coefficients
     sos(v - var'*var),
    %sos(v - vt - (xt-Ax-Bu)'*p                                       )
     sos(v - vt - ((x3-A(1,:)*var)*p1 + (x4-A(2,:)*var)*p2 + (-1)*p2u)),
     cv == cvt,
     ];

opts = sdpsettings('solver','mosek','verbose',0);

sol = solvesos(F, [], opts, [c1;c2;c2u;cv;cvt])

%% extract solution

syms z1 z2 z3 z4
var = [z1;z2];
var_aug = [z1;z2;z3;z4];

cv = value(cv);     cv = cv.*(cv>=1e-6 | cv<=-1e-6);    % clean small values
c1 = value(c1);     c1 = c1.*(c1>=1e-9 | c1<=-1e-9);
c2 = value(c2);     c2 = c2.*(c2>=1e-9 | c2<=-1e-9);
c2u = value(c2u);   c2u = c2u.*(c2u>=1e-6 | c2u<=-1e-6);

vv = monomials(var, 1:dv);
if ~FLAG
    % p(x)
    v1 =  monomials(var, 0:dp);
    v2 =  monomials(var, 0:dp);
    v2u = monomials(var, 0:dp);
else
    % p(x, \tilde{x})
    v1 =  monomials(var_aug, 0:dp); 
    v2 =  monomials(var_aug, 0:dp);
    v2u = monomials(var_aug, 0:dp);
end

V = cv'*vv;
P1 = c1'*v1; 
P2 = c2'*v2; 
P2U = c2u'*v2u;

U = P2U/P2;     % extract u = p2u / p2

V = matlabFunction(V);
P1 = matlabFunction(P1);
P2 = matlabFunction(P2);
P2U = matlabFunction(P2U);
U = matlabFunction(U);

% check if V is sos

figure()
fc = fcontour(V,[-2 2 -2 2]);
fc.LevelList = [0:20];
colorbar
hold on

%% test trajectory with p(x, tilde x)

sdpvar u
tol = 1e-8;

curr = [2; 1];
traj = curr;
ulog = [];
Vlog = V(curr(1),curr(2));
plot(curr(1),curr(2),'or')

% opts = sdpsettings('solver','mosek','verbose',1);
for i = 1:20
    next = A*curr + B*u;
    
    F = [
        V(curr(1),curr(2)) >= V(next(1),next(2)) + tol
        ];
    sol = optimize(F,norm(u),opts);
    if sol.problem ~= 0
        checkV(traj, V)
        error('Infeasible problem at i=%d iteration', i)
    end
    
    ulog = [ulog, value(u)];
    traj = [traj, value(next)];
    Vlog = [Vlog, V(value(next(1)),value(next(2)))];
    
    curr = value(next);
    
end

plot(traj(1,:),traj(2,:),'--')
hold off

figure()
plot(1:length(Vlog),Vlog)
%% auxiliary functions 

% check V(traj)
function checkV(traj, V)
    for j = 1:length(traj)
        V(traj(1,j), traj(2,j))
    end
end